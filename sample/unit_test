#!/usr/sup/bin/python
"""
    unit_test

    This script runs the unit testing framework for comp15 fall 2021.

    Create individiual test functions in unit_tests.h
    Each test function will be run (basically) as its own main.
    Each test function must return void and take no arguments.
    If a test finishes execution, it is considered successful.
    Thus, you can use assert statements to assert known conditions.
    For example:

        void insert_test_0() {
            ArrayList a;
            a.insert(100);
            assert(a[0] == 100);
        }

    You also may put files in stdin/ & stdout/ with the same name as the test.

    Such files in stdin/ will be sent to stdin for the test.
    Such files in stdout/ will be diff'd with the student's stdout for the test.

    If a file is diff'd, then the test will only pass if:
        it completes execution and
        the diff is empty

    To that end, you might do the following for a unit test:

        void insert_test_1 {
            ArrayList a;
            int someval;
            std::cin >> someval;
            a.insert(someval);
            assert(a[0] == someval);
            std::cout << a[0];
        }

    unit testing assignments must be built with our driver file
        
        unit_test_driver.cpp

    This script creates this file and adapts the Makefile to compile all
    student .cpp files not named '(anything_here_)main(.cpp)' and link them
    with this file.
"""
import sys
import os
import re
import json
import subprocess
from pathlib import Path

ASSIGN_TYPE   = 'unit-test'

UNIT_TESTING  = ASSIGN_TYPE == 'unit-test'

DRIVER_MODE   = True 

# directories and files
STDIN_DIR     = 'stdin/'
STDOUT_DIR    = 'stdout/'
EXEC          = 'a.out'
MAKE_TARGET   = 'unit_test'
TIMEOUT       = '30'

# bools
SHOW_OSTREAMS = True
IGNORE_WSPACE = False

# colors
FAILURE       = "31"                 
SUCCESS       = "32"
INFO          = "34"
OSTREAM       = "35"
OUTPUT        = "37"

TMPFILE = "tmp"
open(TMPFILE, 'w').close()  # create the file on disk.

# diff -wB ignores newlines and all whitespace differences.
if IGNORE_WSPACE:
    IGNORE_WSPACE = "-wB"
else:
    IGNORE_WSPACE = ""

# location specified by gradescope [do not change]
RESULTS_FILE   = './results'

# unit-testing specific variables    [do not change]
UTESTFILE      = 'unit_tests.h'
DRIVERCONTENTS = """
/*
unit_test_driver.cpp
Matt Russell
COMP15 2020 Summer
Updated 12/16/2020

This file is used as the driver for unit testing.

The 'tests' map will be auto-populated in the form:

    { "test_name", test_name }

Where "test_name" maps to the associated test function in unit_tests.h.
*/

#include <map>
#include <string>
#include <iostream>
#include "unit_tests.h"

typedef void (*FnPtr)();

int main(int argc, char **argv) {

    /* will be filled in by the unit_test script */
    std::map<std::string, FnPtr> tests {

    };

    /* first argument to main() is the string of a test function name */
    if (argc <= 1) {
        std::cout << "No test function specified. Quitting" << std::endl;
        return 1;
    }

    /* extract the associated fn pointer from "tests", and run the test */
    FnPtr fn = tests[argv[1]];
    fn();

    return 0;
}
""".split("\n")
DRIVERFILE = 'unit_test_driver.cpp'


def INFORM(s, color=OUTPUT):
    """
    prints a string to stderr with the specified output color

        Parameters:
            s (string)   : the string to print
            color (int)  : the color code to print

        Returns:
            none

        Notes:
            \033[1;INTm sets the current terminal text color to be the code INT
            \033[0m returns the terminal text color to black

        Effects:
            color stream is printed, and terminal char color returns to black.
    """
    sys.stderr.write("\033[1;" + color + "m" + s + "\033[0m\n")


def RUN(cmd_ary, stdin=None):
    """
        Runs the subprocess module on the given command and returns the result.

        Parameters:
            cmd_ary (list) : list of command and options to run
            stdin (string) : file to send to stdin, or None

        Returns:
            (completedProcess) : the result of the completed subprocess module

        Notes:
            if no stdin argument, use temporary file as fake stdin.
            Always capture output and use universal newlines.
            Always add a timeout argument of length specified in config.ini
    """
    cmd_ary = ["timeout", TIMEOUT] + cmd_ary
    with open(TMPFILE, 'r') as tmp:
        if stdin == None:
            stdin = tmp
        return subprocess.run(cmd_ary, stdin=stdin, capture_output=True,
                                                    universal_newlines=True)

def extract_test_names():
    """
    finds test names

        Returns:
            test names (list (strings)) : names of the tests

        Notes:
            if unit-test, test names come from from unit test file unit_tests.h
            if diff-only, test names come from file names in stdin
        
    """
    TESTS_FILE = Path(UTESTFILE).read_text()
    CMTD_REGEX = r"\/\*([\s\S]*?)\*\/\s*|\s*\/\/.*\n*"
    TESTS_FILE = re.sub(CMTD_REGEX, '\n', TESTS_FILE)
    TEST_REGEX = r"\n\s*void .*\(\)\s*"
    SIGNATURES = re.findall(TEST_REGEX, TESTS_FILE)
    TEST_NAMES = [x.split()[1].split("(")[0] for x in SIGNATURES]
    
    return TEST_NAMES


def create_driver_file(TEST_NAMES):
    """
    creates a unit testing driver file with the test names from unit_tests.h

    Parameters:
        TEST_NAMES list(string) : list of the names of the tests of the form
                                :  "{ string, void (*FnPtr)() },"
    Returns:
        none

    Effects:
        updates the DRIVERFILE in the cwd with the tests.
        after this function runs, and you compile, you can run each test with:
            ./a.out test_name
    """
    TEST_PAIRS = "\n".join(['\t{ "%s", %s },' % (name, name)
                            for name in TEST_NAMES])
    INSERT_LOC = (
        DRIVERCONTENTS.index(
            "    std::map<std::string, FnPtr> tests {") + 1
    )
    DRIVERCONTENTS.insert(INSERT_LOC, TEST_PAIRS)
    Path(DRIVERFILE).write_text("\n".join(DRIVERCONTENTS))

def compile_driver():
    """
    compiles the unit testing driver into unit_testing_driver.o

    Parameters:
        none
        
    Returns:
        none

    Effects:
        removes DRIVERFILE after creating unit_test_driver.o
    """
    return RUN(['clang++', '-std=c++14', '-c', '-Wall', '-Wextra', DRIVERFILE, '-o', \
                'unit_test_driver.o'])

#Note: I've decided to separate the functions for test with the test object...
#So Test is basically a struct.
class Test:
    def __init__(self, name):
        """
        initialize all of the member variables for a test

        Parameters:
            name (string) : name of the test

        Prereqisites:
            stdin files are located in STDIN_DIR
            stdin files have the same name as the test

            solution stdout files are located in STDOUT_DIR
            solution stdout files have the same as the test

        Returns:
            a test dictionary

        """
        self.name             = name
        self.hr_name          = " ".join(name.split("_"))
        self.standard_test    = None
        self.valgrind_test    = None
        self.diff_test        = None        

        if os.path.isdir(STDIN_DIR) and name in os.listdir(STDIN_DIR):
            self.stdinFile = STDIN_DIR + name
        else:
            self.stdinFile = TMPFILE

        if os.path.isdir(STDOUT_DIR) and name in os.listdir(STDOUT_DIR):
            self.solution_stdoutFile = os.path.join(STDOUT_DIR, name)
        else:
            self.solution_stdoutFile = TMPFILE


def test_passed(test):
    """ report whether the test passed or not. assumes test has been run """
    return test.standard_test.returncode == 0 and \
          (test.diff_test == None or test.diff_test.returncode == 0)


def valgrind_passed(test):
    """ report whether the valgrind test passed. assumes valgrind test ran. """
    return test.valgrind_test.returncode == 0


def stdin_exists(test):
    """ return true if a stdin file exists for this test """
    return test.stdinFile != TMPFILE


def solution_stdout_exists(test):
    """ return true if a solution stdout file exists for this test """
    return test.solution_stdoutFile != TMPFILE


def run_diff(test):
    """
    runs diff on student output and reference output

    Assumptions:
        Empty diff means student passes.

    Returns:
        updated test

    Effects:
        Writes student output to a file named student_stdout

    Notes:
        If custom output file is specified, diff that with solution as well
        If IGNORE_WSPACE from config.ini, run diff -wB
    """
    Path("student_stdout").write_text(test.standard_test.stdout)
    
    diffcmd = ["diff",
               "student_stdout",
               test.solution_stdoutFile]

    if IGNORE_WSPACE:
        diffcmd.append(IGNORE_WSPACE)

    test.diff_test = RUN(diffcmd)
    
    return test


def run_test(test):
    """
    runs the test via the subprocess module. if the test passes, diff results.

    Parameters:
        None

    Assumptions:
        If there is no solution stdout, the test will pass if it finishes

    Notes:
        runs subprocess with capture_output=True, so python stores results in
        self.standard_test.stdout, (and .stderr)

        tests will be run in the form: ./a.out test_name

        in both cases, the stdin variable of subprocess.run() will be set to the
        file handle of the stdinput file.
        
        if there is no stdin, a dummy empty file will be used as stdin.

    Returns:
        none
    """

    exec_list = ["./" + EXEC]
    exec_list.append(test.name)

    with open(test.stdinFile, "r") as stdin:
        test.standard_test = RUN(exec_list, stdin=stdin)

    if test.standard_test.returncode == 0 and solution_stdout_exists(test):
        test = run_diff(test)

    if 'timeout:' in test.standard_test.stderr:
        test.standard_test.stderr = test.standard_test.stderr.split('timeout:')[0]

    return test


def run_valgrind(test):
    """
    runs valgrind on the test and saves the results

    Parameters:
        none

    Notes:
        **IMPORTANT**: --error-exitcode=1 must be set.
                        This will cause errors/leaks to return non-zero.
                        Otherwise, memory errors won't be caught!!!
    Returns:
        updated test object
    """
    valgrind_command = [
        "valgrind",
        "--show-leak-kinds=all",
        "--leak-check=full",  # leaks shown as errors
        "--error-exitcode=1",  # errors/leaks return 1
        "./" + EXEC,
    ]

    valgrind_command.append(test.name)

    with open(test.stdinFile, "r") as stdin:
        test.valgrind_test = RUN(valgrind_command, stdin=stdin)

    return test


def ostream_report(test):
    """
    prints the results of a given test's stdout / stderr to the terminal

    Parameters:
        test (Completed Process) : a subprocess object with stdout/stderr fields

    Returns:
        none
    """        
    if test.stdout:
        INFORM("stdout:", color=OSTREAM)
        INFORM(test.stdout, color=OSTREAM)        
    if test.stderr:
        INFORM("stderr:", color=OSTREAM)
        INFORM(test.stderr, color=OSTREAM)
        INFORM("\n")   
    else:
        if test.stdout:
            INFORM("\n")

def report_test(test):
    """ report results of a test """
    if test_passed(test):
        INFORM(test.hr_name + " passed", color=SUCCESS)        
    else:
        if test.standard_test.returncode == 124:
            INFORM(test.hr_name + " timed out", color=FAILURE)
        else:
            INFORM(test.hr_name + " failed", color=FAILURE)
        
        if abs(TEST_RESULT.returncode) == 11:
            inform("segmentation fault!", color=FAILURE)
    if SHOW_OSTREAMS:
        ostream_report(test.standard_test)        
        INFORM("diff test results", color=INFO)
        ostream_report(test.diff_test)


def report_valgrind(test):
    """ report results of a test """
    if test.valgrind_test == None: 
        INFORM("no valgrind for this test by default", color=SUCCESS)
    elif valgrind_passed(test):
        INFORM("valgrind " + test.hr_name + " passed", color=SUCCESS)
    else:
        if test.valgrind_test.returncode == 124:
            INFORM("valgrind " + test.hr_name + " timed out", color=FAILURE)
        else:
            INFORM("valgrind " + test.hr_name + " failed", color=FAILURE)
        if SHOW_OSTREAMS:
            ostream_report(test.valgrind_test)    

def compile_tests():
    """
    compile the target executable

    Prerequisites:
        MAKE_TARGET and EXEC set in config.ini

    Parameters:
        None

    Returns:
        compilation_result (result of running subprocess module)
    """
    compilation_result = RUN(["make", MAKE_TARGET])    

    if EXEC not in os.listdir('./') and compilation_result.returncode == 0:
        compilation_result.stderr = "Executable produced by 'make unit_test' must be named: " + EXEC
        compilation_result.returncode = 1

    # for some reason, g++ doesn't always play nice, so chmod the executable
    chmod_result = RUN(["chmod", "u+x", EXEC])
    
    return compilation_result


def prepare_tests():
    """
    Extract test names, copy extra files to cwd, and update Makefile info

        Returns:
            test_names list(string): names of the tests to be run
        Effects:
            if either driver compilation or test compilation fails, report so
            and exit(1)
    """
    INFORM("== compiling tests ==")
    
    test_names = extract_test_names()

    create_driver_file(test_names)
    driver_compilation_result = compile_driver()
    compilation_result = compile_tests()
    
    if driver_compilation_result.returncode != 0:
        INFORM("driver failed to compile", color=FAILURE)
        INFORM(driver_compilation_result.stderr)
        if DRIVERFILE in os.listdir("./"):
            os.remove(DRIVERFILE)
        exit(1)
        
    if compilation_result.returncode != 0:
        INFORM("compilation failed")
        INFORM(compilation_result.stderr)
        torem = [DRIVERFILE, 'unit_test_driver.o']
        for f in torem:
            if f in os.listdir("./"):
                os.remove(f)
        exit(1)
        
    print(compilation_result.stdout)
    print(compilation_result.stderr)
    INFORM("tests compiled successfully\n", color=INFO)

    return test_names


def report_results(tests):         
    passed_tests = [name for name, test in tests.items() if test_passed(test)]
    failed_tests = [name for name, test in tests.items() if name not in passed_tests]    

    num_passed = str(len(passed_tests))    
    num_failed = str(len(failed_tests))
    
    valgrind_passed_tests = [name for name, test in tests.items() if valgrind_passed(test)]
    valgrind_failed_tests = [name for name, test in tests.items() if name not in \
                             valgrind_passed_tests and name in passed_tests]
    
    num_valgrind_passed = str(len(valgrind_passed_tests))
    num_valgrind_failed = str(len(valgrind_failed_tests))

    valgrind_failed_by_default = [name for name, test in tests.items() if name in failed_tests]
    num_valgrind_failed_by_default = str(len(valgrind_failed_by_default))
    
   
    INTERNAL_HEADER_START = '\t'
    INTERNAL_BLOCK_SEP    = '\n\t\t'
    DOUBLE_BLOCK_SEP      = INTERNAL_BLOCK_SEP + '\t'

    pstr = ""
 
    pstr += "\n== test output for passing tests ==\n"
    
    for test in passed_tests:
        if tests[test].standard_test.stdout:
            pstr += test + ' - stdout\n' + '-' * len(test + ' - stdout') + '\n'
            pstr += tests[test].standard_test.stdout + '\n'
        if tests[test].standard_test.stderr:
            pstr += test + ' - stderr\n' + '-' * len(test + ' - stderr') + '\n'
            pstr += tests[test].standard_test.stderr + '\n'
    
    if not passed_tests:
        pstr += "(none)\n"     
    
    pstr += "\n== test output for failing tests ==\n"
    
    for test in failed_tests:
        if tests[test].standard_test.stdout and 'utf-8' not in \
           tests[test].standard_test.stdout:
            pstr += test + ' - stdout\n' + '-' * len(test + ' - stdout') + '\n'
            pstr += tests[test].standard_test.stdout + '\n'
        if tests[test].standard_test.stderr and 'utf-8' not in \
           tests[test].standard_test.stderr:
            pstr += test + ' - stderr\n' + '-' * len(test + ' - stderr') + '\n'
            pstr += tests[test].standard_test.stderr + '\n'

        if tests[test].diff_test:
            pstr += test + ' - diff test result\n' + '-' * len(test + ' - diff test result') + '\n'
            pstr += tests[test].diff_test.stdout + '\n'
            pstr += tests[test].diff_test.stderr + '\n'
            
        if tests[test].standard_test.returncode == 11:
            pstr += test + " caused a segmentation fault\n"    
        if 'utf-8' in tests[test].standard_test.stderr or 'utf-8' in \
                      tests[test].standard_test.stdout:
            pstr += test + " has run undefined behavior in your code,\n" + \
                    "which caused your program to crash. This is likely\n" + \
                    "due to uninitialized variable access.\n"
    
    if not failed_tests:
        pstr += "(none)\n" 
    
    pstr += "\n== valgrind output for failing tests ==\n"    
    
    for test in valgrind_failed_tests:
        if tests[test].valgrind_test.stderr:
            pstr += test + ' - valgrind stderr\n' + '-' * len(test + ' - valgrind stderr') + '\n'
            pstr += tests[test].valgrind_test.stderr + '\n'
    
    if not valgrind_failed_tests:
        pstr += "(none)\n\n" 
    
    
    pstr += "== test summary ==\n"
    pstr += "number of tests passed: " + num_passed + '\n'
    pstr += "number of tests failed: " + num_failed + '\n'
    pstr += "number of valgrind tests passed: " + num_valgrind_passed + '\n'
    pstr += "number of valgrind tests failed: " + num_valgrind_failed + '\n'
    
    pstr += "\n== test results ==\n"
    if passed_tests:
        pstr += "passing tests - " + repr(passed_tests) + '\n'
    else: 
        pstr += "passing tests - (none)\n"
        
    if failed_tests:
        pstr += "failing tests - " + repr(failed_tests) + '\n'
    else: 
        pstr += "failing tests - (none)\n"
    
    pstr += "\n== valgrind results ==\n"
    if valgrind_passed_tests:
        pstr += "passing valgrind tests - " + repr(valgrind_passed_tests) + '\n'
    else:
        pstr += "passing valgrind tests - (none)\n"

    if valgrind_failed_tests:
        pstr += "failing valgrind tests - " + repr(valgrind_failed_tests) + '\n'
    else:
        pstr += "failing valgrind tests - (none)\n"
        
    pstr += "\nsee above for test output\n"
    
    print(pstr)

if __name__ == "__main__":

    if len(sys.argv > 1) and sys.arvg[1] == "-n" or sys.argv[1] == "--no-driver-mode":
        DRIVER_MODE = False

    tests = {}
    
    test_names = prepare_tests()
    
    for name in test_names:
        test = Test(name)
        test = run_test(test)               
        test = run_valgrind(test)

        tests[test.hr_name] = test
        #INFORM(test.hr_name, color=INFO)
        #report_test(test)        
        #INFORM('\n')
    report_results(tests)
    
    toRemove = [TMPFILE, 'student_stdout', 'unit_test_driver.cpp', \
                'unit_test_driver.o','a.out']
    for f in toRemove:
        if f in os.listdir('./'):
            os.remove(f)
    
